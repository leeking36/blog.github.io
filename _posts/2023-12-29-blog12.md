---
layout: post
title: JS 高级用法
anchor: blog11
excerpt: JS 的优雅写法
update: 2023 年 12 月 29 日
---

## 模仿接口

## 类

<img src="https://leeking36.github.io/images/Snipaste_2024-01-12_17-31-30.png" width="50%">

## 继承

类式继承、原型式继承

## 单体模式

单例模式，只保存一份实例，可以确保所有代码只用的都是通用的全局资源。

## 方法的链式调用

例如 JQuery：一个创建代表 HTML 元素的对象的工厂，以及一批对这个 HTML 元素执行某些操作的方法，每个方法都返回该 HTML 元素。

<img src="https://leeking36.github.io/images/IMG20240117-103320220.png" width="50%">

## 工厂模式

适用于创建一些用不同方式实现同一接口的对象：把成员对象的创建工作（new）转交给一个外部对象，这个外部对象可以是一个简单的命名空间，也可以是一个类的实例。

<img src="https://leeking36.github.io/images/Snipaste_2024-01-17_14-33-05.png" width="50%">

## 桥接模式

实现 API：将抽象与其实现隔离开来，可以用来把一组类和函数链接起来，提供一种借助于特权函数访问使用数据的手段，常应用于事件监听回调函数。

## 组合模式

动态用户界面：可以用一条命令在多个对象（有某种层次体系的对象）上激发复杂的或递归的行为。

<img src="https://leeking36.github.io/images/Snipaste_2024-01-19_15-04-43.png" width="50%">

## 门面模式

简化类和对象的接口：适用重复性的任务，如便利函数、 jQuery 等第三方库。

```javascript
function addEvent(el, type, fn) {
  if (window.addEventListener) {
    el.addEventListener(type, fn, false);
  } else if (window.attachEvent) {
    el.attachEvent("on" + type, fn);
  } else {
    el["on" + type] = fn;
  }
}
```

## 适配器模式

用来在现有接口和不兼容的类之间进行适配，也叫包装器：用一个新的接口包装另一个对象。

```javascript
var clientObject = {
  string1: 'foo',
  string2: 'bar',
  string3: 'baz'
};
function interfaceMethod(str1, str2, str3) {
  ...
}
// 包装函数
function clientToInterfaceAdapter(o) {
  interfaceMethod(o.string1, o.string2, o.string3);
}
/* Usage. */
clientToInterfaceAdapter(clientObject);
```

## 装饰者模式

`为对象增加功能或修改行为，用来替代大量子类。`
`或可用来包装独立的函数和方法：被装饰者作为装饰器函数的参数 func，在装饰器函数内返回的函数中使用 func.apply 执行被装饰者。`

```javascript
var BicycleDecorator = function (bicycle) {
  // implements Bicycle
  Interface.ensureImplements(bicycle, Bicycle);
  this.bicycle = bicycle;
};
BicycleDecorator.prototype = {
  assemble: function () {
    return this.bicycle.assemble() + " Attach headlight to handlebars.";
  },
  wash: function () {
    return this.bicycle.wash();
  },
  ride: function () {
    return this.bicycle.ride();
  },
  repair: function () {
    return this.bicycle.repair();
  },
  getPrice: function () {
    return this.bicycle.getPrice() + 15.0;
  },
};

var myBicycle = new Bicycle();
alert(myBicycle.getPrice()); // Returns 399.00

myBicycle = new BicycleDecorator(myBicycle);
alert(myBicycle.getPrice()); // Now returns 414.00
```

## 享元模式

解决因创建大量类似对象而累及性能的问题，将对象的内部状态划分为内在数据和外在数据两类，内在数据是指的内部方法所需要的信息，没有这种数据的话类就不能正常运转，外在数据则是可以从类身上剥离并存储在其外部的信息，我们可以将内在状态相同的所有对象替换为一个共享对象，用这种犯法可以把对象的数量减少到不同内在状态的数量。

## 代理模式

## 观察者模式

## 命令模式

## 责任链模式
