---
layout: post
title: vue3 开发指南
anchor: blog09
excerpt: 保姆级快速上手指南
update: 2023年09月19日
---

## 获取 this

- Vue2 中每个组件里使用 this 都指向当前组件实例，this 上还包含了全局挂载的东西、路由、状态管理等啥啥都有。
- 而 Vue3 中没有 this，如果想要类似的用法，有两种，一是获取当前组件实例，二是获取全局实例。

```json
<script setup>
  import { getCurrentInstance } from 'vue'
  // proxy 就是当前组件实例
  // appContext.config.globalProperties就是全局实例，含全局的路由、状态管理、全局组件等
  const { proxy, appContext } = getCurrentInstance()

  // 也可以通过proxy获取全局属性
  // proxy.$http 全局自定义属性
  // proxy.$router
  // proxy.$route
  // proxy.$pinia
</script>
```

### Vue3 getCurrentInstance 与 ts 结合使用的坑

#### 问题

```json
<script lang="ts" setup>
  import { getCurrentInstance } from 'vue'
  // 首先 此处 proxy ts会报
  // 类型“ComponentInternalInstance | null”上不存在属性“proxy”
  const { proxy } = getCurrentInstance()
  // 然后下面会报这个错误
  // Unsafe member access .$axios on an `any` value.  eslint@typescript-eslint/no-unsafe-member-access
  // Unsafe call of an `any` typed value.  eslint@typescript-eslint/no-unsafe-call
  proxy.$axios('')
</script>
```

#### 解决方法

第一个报错很好理解 因为 getCurrentInstance()的返回类型存在 null 所以在此处添加断言即可

```javascript
import { ComponentInternalInstance, getCurrentInstance } from 'vue'
// 添加断言
const { proxy, appContext } = getCurrentInstance() as ComponentInternalInstance
```

但是改完后我们发现下面依旧会有报错

```javascript
// 对象可能为 "null"。ts(2531)
proxy.$axios("");
```

这个解决起来更简单了，在 proxy 后面添加?来过滤 null 的结果

```javascript
proxy?.$axios("");
```

#### 关于在 ts 中使用到类型定义错误问题

`报错：...类型“ComponentInternalInstance | null”`
解决 1：可以添加 ts 忽略去解决

```javascript
// @ts-ignore
const { proxy } = getCurrentInstance();
```

解决 2：`（推荐使用）`考虑到在获取上下文和全局挂载实例的时候会用到这个 getCurrentInstance，那我们来新建 hooks\useCurrentInstance.ts

```javascript
  import { ComponentInternalInstance, getCurrentInstance } from 'vue'
  export default function useCurrentInstance() {
    const { appContext } = getCurrentInstance() as ComponentInternalInstance
    const globalProperties = appContext.config.globalProperties
    return {
      globalProperties
    }
  }
```

组件中使用：

```javascript
// 先引入文件
import useCurrentInstance from "@/hooks/useCurrentInstance";
// 在setup 中使用处理
const { globalProperties } = useCurrentInstance();
```

#### 不能使用 getCurrentInstance 的 ctx

```javascript
//错误写法，ctx打包后在生产环境下是获取不到的
const { ctx } = getCurrentInstance();
//正确写法
const { proxy } = getCurrentInstance();
```

#### 解决 getCurrentInstance 打包后线上环境报错问题

- getCurrentInstance 只暴露给高阶使用场景，典型的比如在库中。
- 强烈反对在应用的代码中使用 getCurrentInstance，请不要把它当作在组合式 API 中获取 this 的替代方案来使用。
- 在开发环境下使用 getCurrentInstance 的 ctx 获取实例没有问题，但是在线上环境会报错，建议使用 proxy 代替，使用时直接将 proxy 解构出来。
- getCurrentInstance 只能在 setup 或生命周期钩子中调用。

```json
import { getCurrentInstance } from 'vue'
const MyComponent = {
  setup() {
    const { ctx }  = getCurrentInstance();  //  方式一：这种方式只能在开发环境下使用，生产环境下//的ctx将访问不到
    const { proxy }  = getCurrentInstance();  //  方式二：此方法在开发环境以及生产环境下都能放到组件上下文对象（推荐）
  }
}
```

## 全局注册(属性/方法)

Vue2 中我们要往全局上挂载东西通常就是如下，然后在所有组件里都可以通过 this.xxx 获取到了：

```javascript
Vue.prototype.xxx = xxx;
```

而 Vue3 中不能这么写了，换成了一个能被所有组件访问到的全局对象，就是上面说的全局实例的那个对象，比如在 main.js 中做全局注册：

```javascript
// main.js
import { createApp } from "vue";
import App from "./App.vue";
const app = createApp(App);
// 添加全局属性
app.config.globalProperties.$http = xxx;
app.mount("#app");
```

在其他组件中调用：

```json
<script setup>
  import {getCurrentInstance} from 'vue'
  const {appContext} = getCurrentInstance()
  const global = appContext.config.globalProperties
  console.log(global.$http)
</script>
```

## template

- Vue2 中只能有一个根节点，而 Vue3 中支持多个根节点。
- 其实本质上 Vue3 每个组件还是一个根节点，因为 DOM 树只能是树状结构的，只是 Vue3 在编译阶段新增了判断，如果当前组件不只一个根元素，就添加一个 fragment 组件把这个多根组件的给包起来，相当于这个组件还是只有一个根节点。而 fragment 跟 keep-alive 一样是一个不会被渲染出来的内置组件。

```javascript
<template>
  <div>1</div>
  <div>2</div>
</template>
```

## 获取 DOM

Vue3 中获取 DOM 如下

```json
<template>
  <el-form ref="formRef"></el-form>
  <child-component />
</template>
<script setup lang="ts">
  import ChildComponent from './child.vue'
  import { getCurrentInstance } from 'vue'
  import { ElForm } from 'element-plus'

  // 方法一，这个变量名和 DOM 上的 ref 属性必须同名，会自动形成绑定
  const formRef = ref(null)
  console.log(formRef.value) // 这就获取到 DOM 了

  // 方法二
  const { proxy } = getCurrentInstance()
  proxy.$refs.formRef.validate((valid) => { ... })

  // 方法三，比如在 ts 里，可以直接获取到组件类型
  // 可以这样获取子组件
  const formRef = ref<InstanceType<typeof ChildComponent>>()
  // 也可以这样 获取 element ui 的组件类型
  const formRef = ref<InstanceType<typeof ElForm>>()
  formRef.value?.validate((valid) => { ... })
</script>
```

## 初始化

- Vue2 中进入页面就请求接口，或者其他一些初始化的操作，一般放在 created 或 mounted。
- Vue3 中 beforeCreated 和 created 这俩钩子就不用了，因为 setup 在这俩之前执行，还要这俩的话就多此一举了。
- Vue2 中 beforeCreated / created / beforeMount / mounted 这几个钩子里的内容，在 Vue3 中可以直接放在 setup 里，或者放在 onMounted/onBeforeMount 里。

```json
<script setup>
import { onMounted } from 'vue'
// 请求接口函数
const getData = () => {
  xxxApi.then(() => { ... })
}
onMounted(() => {
  getData()
})
</script>
```

## 解除绑定

Vue2 中一般清除定时器、监听之类的操作有两种方法：

- 是用$once 搭配 hook: BeforeDestroy 使用，这个 Vue3 不支持了。
- 是用 beforeDestroy / deactivated 这俩钩子，Vue3 中只是把钩子函数重命名了一下。
  <img src="https://leeking36.github.io/images/lifecycle.16e4c08e.png" width="50%">

```json
<script setup>
import { onBeforeUnmount, onDeactivated } from 'vue'
// 组件卸载前，对应 Vue2 的 beforeDestroy
onBeforeUnmount(() => {
    clearTimeout(timer)
    window.removeAddEventListener('...')
})
// 退出缓存组件，对应 Vue2 的 deactivated
onDeactivated(() => {
    clearTimeout(timer)
    window.removeAddEventListener('...')
})
</script>
```

## ref 和 reactive
